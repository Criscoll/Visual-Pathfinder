{"ast":null,"code":"export default function astar(grid, startNode, endNode, numRows, numCols) {\n  let visitedNodes = [];\n  let openList = [];\n  let closedList = [];\n  initialise(grid, numRows, numCols); //   openList.push(openList);\n  //   while (openList.length !== 0) {\n  //     let currentNode = stack.pop();\n  //     if (Object.keys(node).length === 0) {\n  //       return { visitedNodes: visitedNodes, pathFound: false };\n  //     }\n  //     visitedNodes.push(node);\n  //     if (node.row === endNode.row && node.col === endNode.col) {\n  //       return { visitedNodes: visitedNodes, pathFound: true };\n  //     }\n  //     if (node.visited === false) {\n  //       node.visited = true;\n  //       for (let i = 0; i < node.adjacentNodes.length; i++) {\n  //         let adjacentRow = node.adjacentNodes[i].row;\n  //         let adjacentCol = node.adjacentNodes[i].col;\n  //         if (\n  //           grid[adjacentRow][adjacentCol].visited === false &&\n  //           document.getElementById(`node-${adjacentRow}-${adjacentCol}`)\n  //             .className !== 'wall-node'\n  //         ) {\n  //           stack.push(grid[adjacentRow][adjacentCol]);\n  //           grid[adjacentRow][adjacentCol].prev = node;\n  //         }\n  //       }\n  //     }\n  //   }\n  //   return { visitedNodes: visitedNodes, pathFound: false };\n}\n\nfunction initialise(grid, numRows, numCols) {\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numCols; j++) {\n      let node = grid[i][j];\n      node['f'] = null;\n      node['h'] = null;\n      node['g'] = null;\n    }\n  }\n\n  return grid;\n}\n\nfunction findLowestFCost(openList) {}\n\nfunction heuristicValue(pos0, pos1) {\n  let d1 = Math.abs(pos1.row - pos0.row);\n  let d2 = Math.abs(pos1.col - pos0.col);\n  return d1 + d2;\n}","map":{"version":3,"sources":["/home/cristian/Documents/projects/visual_pathfinder/src/Algorithms/astar.js"],"names":["astar","grid","startNode","endNode","numRows","numCols","visitedNodes","openList","closedList","initialise","i","j","node","findLowestFCost","heuristicValue","pos0","pos1","d1","Math","abs","row","d2","col"],"mappings":"AAAA,eAAe,SAASA,KAAT,CAAeC,IAAf,EAAqBC,SAArB,EAAgCC,OAAhC,EAAyCC,OAAzC,EAAkDC,OAAlD,EAA2D;AACxE,MAAIC,YAAY,GAAG,EAAnB;AACA,MAAIC,QAAQ,GAAG,EAAf;AACA,MAAIC,UAAU,GAAG,EAAjB;AAEAC,EAAAA,UAAU,CAACR,IAAD,EAAOG,OAAP,EAAgBC,OAAhB,CAAV,CALwE,CAOxE;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACD;;AAED,SAASI,UAAT,CAAoBR,IAApB,EAA0BG,OAA1B,EAAmCC,OAAnC,EAA4C;AAC1C,OAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,OAApB,EAA6BM,CAAC,EAA9B,EAAkC;AAChC,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,OAApB,EAA6BM,CAAC,EAA9B,EAAkC;AAChC,UAAIC,IAAI,GAAGX,IAAI,CAACS,CAAD,CAAJ,CAAQC,CAAR,CAAX;AACAC,MAAAA,IAAI,CAAC,GAAD,CAAJ,GAAY,IAAZ;AACAA,MAAAA,IAAI,CAAC,GAAD,CAAJ,GAAY,IAAZ;AACAA,MAAAA,IAAI,CAAC,GAAD,CAAJ,GAAY,IAAZ;AACD;AACF;;AAED,SAAOX,IAAP;AACD;;AAED,SAASY,eAAT,CAAyBN,QAAzB,EAAmC,CAAE;;AAErC,SAASO,cAAT,CAAwBC,IAAxB,EAA8BC,IAA9B,EAAoC;AAClC,MAAIC,EAAE,GAAGC,IAAI,CAACC,GAAL,CAASH,IAAI,CAACI,GAAL,GAAWL,IAAI,CAACK,GAAzB,CAAT;AACA,MAAIC,EAAE,GAAGH,IAAI,CAACC,GAAL,CAASH,IAAI,CAACM,GAAL,GAAWP,IAAI,CAACO,GAAzB,CAAT;AAEA,SAAOL,EAAE,GAAGI,EAAZ;AACD","sourcesContent":["export default function astar(grid, startNode, endNode, numRows, numCols) {\n  let visitedNodes = [];\n  let openList = [];\n  let closedList = [];\n\n  initialise(grid, numRows, numCols);\n\n  //   openList.push(openList);\n\n  //   while (openList.length !== 0) {\n  //     let currentNode = stack.pop();\n\n  //     if (Object.keys(node).length === 0) {\n  //       return { visitedNodes: visitedNodes, pathFound: false };\n  //     }\n\n  //     visitedNodes.push(node);\n\n  //     if (node.row === endNode.row && node.col === endNode.col) {\n  //       return { visitedNodes: visitedNodes, pathFound: true };\n  //     }\n\n  //     if (node.visited === false) {\n  //       node.visited = true;\n\n  //       for (let i = 0; i < node.adjacentNodes.length; i++) {\n  //         let adjacentRow = node.adjacentNodes[i].row;\n  //         let adjacentCol = node.adjacentNodes[i].col;\n\n  //         if (\n  //           grid[adjacentRow][adjacentCol].visited === false &&\n  //           document.getElementById(`node-${adjacentRow}-${adjacentCol}`)\n  //             .className !== 'wall-node'\n  //         ) {\n  //           stack.push(grid[adjacentRow][adjacentCol]);\n  //           grid[adjacentRow][adjacentCol].prev = node;\n  //         }\n  //       }\n  //     }\n  //   }\n  //   return { visitedNodes: visitedNodes, pathFound: false };\n}\n\nfunction initialise(grid, numRows, numCols) {\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numCols; j++) {\n      let node = grid[i][j];\n      node['f'] = null;\n      node['h'] = null;\n      node['g'] = null;\n    }\n  }\n\n  return grid;\n}\n\nfunction findLowestFCost(openList) {}\n\nfunction heuristicValue(pos0, pos1) {\n  let d1 = Math.abs(pos1.row - pos0.row);\n  let d2 = Math.abs(pos1.col - pos0.col);\n\n  return d1 + d2;\n}\n"]},"metadata":{},"sourceType":"module"}