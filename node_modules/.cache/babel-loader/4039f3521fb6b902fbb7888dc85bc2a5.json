{"ast":null,"code":"export default function astar(grid, startNode, endNode, numRows, numCols) {\n  let visitedNodes = [];\n  let openList = [];\n  let closedList = [];\n  initialise(grid, numRows, numCols);\n  openList.push(startNode);\n\n  while (openList.length !== 0) {\n    let currentNode = findLowestFCost(openList); // End case -- result has been found, return the traced path\n\n    if (currentNode.row === endNode.row && currentNode.col === endNode.col) {\n      return {\n        visitedNodes: visitedNodes,\n        pathFound: false\n      };\n    } // Normal case -- move currentNode from open to closed, process each of its neighbors\n\n\n    closedList.push(currentNode);\n\n    for (let i = 0; i < currentNode.adjacentNodes.length; i++) {\n      let neighbor = currentNode.adjacentNodes[i];\n\n      if (isInList(closedList, neighbour) || neighbor.isWall()) {\n        // not a valid node to process, skip to next neighbor\n        continue;\n      } // g score is the shortest distance from start to current node, we need to check if\n      //   the path we have arrived at this neighbor is the shortest one we have seen yet\n\n\n      var gScore = currentNode.g + 1; // 1 is the distance from a node to it's neighbor\n\n      var gScoreIsBest = false;\n\n      if (!openList.findGraphNode(neighbor)) {\n        // This the the first time we have arrived at this node, it must be the best\n        // Also, we need to take the h (heuristic) score since we haven't done so yet\n        gScoreIsBest = true;\n        neighbor.h = astar.heuristic(neighbor.pos, end.pos);\n        openList.push(neighbor);\n      } else if (gScore < neighbor.g) {\n        // We have already seen the node, but last time it had a worse g (distance from start)\n        gScoreIsBest = true;\n      }\n\n      if (gScoreIsBest) {\n        // Found an optimal (so far) path to this node.   Store info on how we got here and\n        //  just how good it really is...\n        neighbor.parent = currentNode;\n        neighbor.g = gScore;\n        neighbor.f = neighbor.g + neighbor.h;\n        neighbor.debug = 'F: ' + neighbor.f + '<br />G: ' + neighbor.g + '<br />H: ' + neighbor.h;\n      }\n    }\n  } // No result was found -- empty array signifies failure to find path\n\n\n  return [];\n}\n\nfunction initialise(grid, numRows, numCols) {\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numCols; j++) {\n      let node = grid[i][j];\n      node['f'] = null;\n      node['h'] = null;\n      node['g'] = null;\n    }\n  }\n\n  return grid;\n}\n\nfunction findLowestFCost(openList) {\n  let lowInd = 0;\n\n  for (let i = 0; i < openList.length; i++) {\n    if (openList[i].f < openList[lowInd].f) {\n      lowInd = i;\n    }\n  }\n\n  let minFNode = openList[i];\n  openList.splice(lowInd, 1);\n  return minFNode;\n}\n\nfunction heuristicValue(pos0, pos1) {\n  let d1 = Math.abs(pos1.row - pos0.row);\n  let d2 = Math.abs(pos1.col - pos0.col);\n  return d1 + d2;\n}\n\nfunction isInList(list, node) {\n  list.forEach(item => {\n    if (item.row === node.row && item.col === node.col) {\n      return true;\n    }\n  });\n  return false;\n}","map":{"version":3,"sources":["/home/cristian/Documents/projects/visual_pathfinder/src/Algorithms/astar.js"],"names":["astar","grid","startNode","endNode","numRows","numCols","visitedNodes","openList","closedList","initialise","push","length","currentNode","findLowestFCost","row","col","pathFound","i","adjacentNodes","neighbor","isInList","neighbour","isWall","gScore","g","gScoreIsBest","findGraphNode","h","heuristic","pos","end","parent","f","debug","j","node","lowInd","minFNode","splice","heuristicValue","pos0","pos1","d1","Math","abs","d2","list","forEach","item"],"mappings":"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","sourcesContent":["export default function astar(grid, startNode, endNode, numRows, numCols) {\n  let visitedNodes = [];\n  let openList = [];\n  let closedList = [];\n\n  initialise(grid, numRows, numCols);\n\n  openList.push(startNode);\n\n  while (openList.length !== 0) {\n    let currentNode = findLowestFCost(openList);\n\n    // End case -- result has been found, return the traced path\n    if (currentNode.row === endNode.row && currentNode.col === endNode.col) {\n      return { visitedNodes: visitedNodes, pathFound: false };\n    }\n\n    // Normal case -- move currentNode from open to closed, process each of its neighbors\n    closedList.push(currentNode);\n\n    for (let i = 0; i < currentNode.adjacentNodes.length; i++) {\n      let neighbor = currentNode.adjacentNodes[i];\n      if (isInList(closedList, neighbour) || neighbor.isWall()) {\n        // not a valid node to process, skip to next neighbor\n        continue;\n      }\n\n      // g score is the shortest distance from start to current node, we need to check if\n      //   the path we have arrived at this neighbor is the shortest one we have seen yet\n      var gScore = currentNode.g + 1; // 1 is the distance from a node to it's neighbor\n      var gScoreIsBest = false;\n\n      if (!openList.findGraphNode(neighbor)) {\n        // This the the first time we have arrived at this node, it must be the best\n        // Also, we need to take the h (heuristic) score since we haven't done so yet\n\n        gScoreIsBest = true;\n        neighbor.h = astar.heuristic(neighbor.pos, end.pos);\n        openList.push(neighbor);\n      } else if (gScore < neighbor.g) {\n        // We have already seen the node, but last time it had a worse g (distance from start)\n        gScoreIsBest = true;\n      }\n\n      if (gScoreIsBest) {\n        // Found an optimal (so far) path to this node.   Store info on how we got here and\n        //  just how good it really is...\n        neighbor.parent = currentNode;\n        neighbor.g = gScore;\n        neighbor.f = neighbor.g + neighbor.h;\n        neighbor.debug =\n          'F: ' +\n          neighbor.f +\n          '<br />G: ' +\n          neighbor.g +\n          '<br />H: ' +\n          neighbor.h;\n      }\n    }\n  }\n\n  // No result was found -- empty array signifies failure to find path\n  return [];\n}\n\nfunction initialise(grid, numRows, numCols) {\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numCols; j++) {\n      let node = grid[i][j];\n      node['f'] = null;\n      node['h'] = null;\n      node['g'] = null;\n    }\n  }\n\n  return grid;\n}\n\nfunction findLowestFCost(openList) {\n  let lowInd = 0;\n  for (let i = 0; i < openList.length; i++) {\n    if (openList[i].f < openList[lowInd].f) {\n      lowInd = i;\n    }\n  }\n  let minFNode = openList[i];\n  openList.splice(lowInd, 1);\n  return minFNode;\n}\n\nfunction heuristicValue(pos0, pos1) {\n  let d1 = Math.abs(pos1.row - pos0.row);\n  let d2 = Math.abs(pos1.col - pos0.col);\n\n  return d1 + d2;\n}\n\nfunction isInList(list, node) {\n  list.forEach((item) => {\n    if (item.row === node.row && item.col === node.col) {\n      return true;\n    }\n  });\n  return false;\n}\n"]},"metadata":{},"sourceType":"module"}