{"ast":null,"code":"export default function dikstrasAlgorithm(grid, startNode, endNode) {\n  // let visitedNodes = [];\n  // let queue = [];\n  // startNode.dist = 0;\n  // for (let i = 0; i < grid.maxRow; i++) {\n  //   for (let j = 0; j < grid.maxCol; j++) {\n  //     queue.push(grid.nodes[i][j]);\n  //   }\n  // }\n  // while (!queue.empty) {\n  //   let s = findMinimum(queue);\n  //   visitedNodes.push(s);\n  //   if (s.row == endNode.row && s.col == endNode.col) {\n  //     return visitedNodes;\n  //   }\n  //   for (let i = 0; i < s.adjacentNodes.length; i++) {\n  //     let alt = s.adjacentNodes[i].dist + distance(s, s.adjacentNodes[i]);\n  //     if (alt < s.adjacentNodes[i].dist) {\n  //       s.adjacentNodes[i].dist = alt;\n  //       s.adjacentNodes[i].prev = s;\n  //     }\n  //   }\n  console.log(distance()); // }\n  // return visitedNodes;\n} // change this when weights are implemented\n\nfunction distance(u, v) {\n  return 1;\n}\n\nfunction findMinimum(queue) {\n  let min = Infinity;\n  let minIdx = 0;\n  let minItem = {};\n\n  for (let i = 0; i < queue.length; i++) {\n    if (queue[i].dist < min) {\n      min = queue[i].dist;\n      minIdx = i;\n      minItem = queue[i];\n    }\n  }\n\n  queue.splice(minIdx, 1);\n  return minItem;\n}","map":{"version":3,"sources":["/home/cristian/Documents/projects/visual_pathfinder/my-app/src/Algorithms/dijkstras.js"],"names":["dikstrasAlgorithm","grid","startNode","endNode","console","log","distance","u","v","findMinimum","queue","min","Infinity","minIdx","minItem","i","length","dist","splice"],"mappings":"AAAA,eAAe,SAASA,iBAAT,CAA2BC,IAA3B,EAAiCC,SAAjC,EAA4CC,OAA5C,EAAqD;AAClE;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACAC,EAAAA,OAAO,CAACC,GAAR,CAAYC,QAAQ,EAApB,EA3BkE,CA4BlE;AAEA;AACD,C,CAED;;AACA,SAASA,QAAT,CAAkBC,CAAlB,EAAqBC,CAArB,EAAwB;AACtB,SAAO,CAAP;AACD;;AAED,SAASC,WAAT,CAAqBC,KAArB,EAA4B;AAC1B,MAAIC,GAAG,GAAGC,QAAV;AACA,MAAIC,MAAM,GAAG,CAAb;AACA,MAAIC,OAAO,GAAG,EAAd;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGL,KAAK,CAACM,MAA1B,EAAkCD,CAAC,EAAnC,EAAuC;AACrC,QAAIL,KAAK,CAACK,CAAD,CAAL,CAASE,IAAT,GAAgBN,GAApB,EAAyB;AACvBA,MAAAA,GAAG,GAAGD,KAAK,CAACK,CAAD,CAAL,CAASE,IAAf;AACAJ,MAAAA,MAAM,GAAGE,CAAT;AACAD,MAAAA,OAAO,GAAGJ,KAAK,CAACK,CAAD,CAAf;AACD;AACF;;AAEDL,EAAAA,KAAK,CAACQ,MAAN,CAAaL,MAAb,EAAqB,CAArB;AACA,SAAOC,OAAP;AACD","sourcesContent":["export default function dikstrasAlgorithm(grid, startNode, endNode) {\n  // let visitedNodes = [];\n\n  // let queue = [];\n  // startNode.dist = 0;\n  // for (let i = 0; i < grid.maxRow; i++) {\n  //   for (let j = 0; j < grid.maxCol; j++) {\n  //     queue.push(grid.nodes[i][j]);\n  //   }\n  // }\n\n  // while (!queue.empty) {\n  //   let s = findMinimum(queue);\n  //   visitedNodes.push(s);\n\n  //   if (s.row == endNode.row && s.col == endNode.col) {\n  //     return visitedNodes;\n  //   }\n\n  //   for (let i = 0; i < s.adjacentNodes.length; i++) {\n  //     let alt = s.adjacentNodes[i].dist + distance(s, s.adjacentNodes[i]);\n\n  //     if (alt < s.adjacentNodes[i].dist) {\n  //       s.adjacentNodes[i].dist = alt;\n  //       s.adjacentNodes[i].prev = s;\n  //     }\n  //   }\n  console.log(distance());\n  // }\n\n  // return visitedNodes;\n}\n\n// change this when weights are implemented\nfunction distance(u, v) {\n  return 1;\n}\n\nfunction findMinimum(queue) {\n  let min = Infinity;\n  let minIdx = 0;\n  let minItem = {};\n\n  for (let i = 0; i < queue.length; i++) {\n    if (queue[i].dist < min) {\n      min = queue[i].dist;\n      minIdx = i;\n      minItem = queue[i];\n    }\n  }\n\n  queue.splice(minIdx, 1);\n  return minItem;\n}\n"]},"metadata":{},"sourceType":"module"}