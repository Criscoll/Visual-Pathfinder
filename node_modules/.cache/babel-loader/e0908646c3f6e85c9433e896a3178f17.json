{"ast":null,"code":"export function dikstrasAlgorithm(grid, startNode, endNode) {\n  let visitedNodes = [];\n  let queue = [];\n  startNode.dist = 0;\n\n  for (let i = 0; i < grid.maxRow; i++) {\n    for (let j = 0; j < grid.maxCol; j++) {\n      queue.push(grid.nodes[i][j]);\n    }\n  }\n\n  while (!queue.empty) {\n    let s = findMinimum(queue);\n    visitedNodes.push(s);\n\n    if (s.row == endNode.row && s.col == endNode.col) {\n      return visitedNodes;\n    }\n\n    for (let i = 0; i < s.adjacentNodes.length; i++) {\n      let alt = s.adjacentNodes[i].dist + distance(s, s.adjacentNodes[i]);\n\n      if (alt < s.adjacentNodes[i].dist) {\n        s.adjacentNodes[i].dist = alt;\n        s.adjacentNodes[i].prev = s;\n      }\n    }\n  }\n\n  return visitedNodes;\n} // change this when weights are implemented\n\nfunction distance(u, v) {\n  return 1;\n}\n\nfunction findMinimum(queue) {\n  let min = Infinity;\n  let minIdx = 0;\n  let minItem = {};\n\n  for (let i = 0; i < queue.length; i++) {\n    if (queue[i].dist < min) {\n      min = queue[i].dist;\n      minIdx = i;\n      minItem = queue[i];\n    }\n  }\n\n  queue.splice(minIdx, 1);\n  return minItem;\n}","map":{"version":3,"sources":["/home/cristian/Documents/projects/visual_pathfinder/my-app/src/Algorithms/dijkstras.js"],"names":["dikstrasAlgorithm","grid","startNode","endNode","visitedNodes","queue","dist","i","maxRow","j","maxCol","push","nodes","empty","s","findMinimum","row","col","adjacentNodes","length","alt","distance","prev","u","v","min","Infinity","minIdx","minItem","splice"],"mappings":"AAAA,OAAO,SAASA,iBAAT,CAA2BC,IAA3B,EAAiCC,SAAjC,EAA4CC,OAA5C,EAAqD;AAC1D,MAAIC,YAAY,GAAG,EAAnB;AAEA,MAAIC,KAAK,GAAG,EAAZ;AACAH,EAAAA,SAAS,CAACI,IAAV,GAAiB,CAAjB;;AACA,OAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGN,IAAI,CAACO,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpC,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,IAAI,CAACS,MAAzB,EAAiCD,CAAC,EAAlC,EAAsC;AACpCJ,MAAAA,KAAK,CAACM,IAAN,CAAWV,IAAI,CAACW,KAAL,CAAWL,CAAX,EAAcE,CAAd,CAAX;AACD;AACF;;AAED,SAAO,CAACJ,KAAK,CAACQ,KAAd,EAAqB;AACnB,QAAIC,CAAC,GAAGC,WAAW,CAACV,KAAD,CAAnB;AACAD,IAAAA,YAAY,CAACO,IAAb,CAAkBG,CAAlB;;AAEA,QAAIA,CAAC,CAACE,GAAF,IAASb,OAAO,CAACa,GAAjB,IAAwBF,CAAC,CAACG,GAAF,IAASd,OAAO,CAACc,GAA7C,EAAkD;AAChD,aAAOb,YAAP;AACD;;AAED,SAAK,IAAIG,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGO,CAAC,CAACI,aAAF,CAAgBC,MAApC,EAA4CZ,CAAC,EAA7C,EAAiD;AAC/C,UAAIa,GAAG,GAAGN,CAAC,CAACI,aAAF,CAAgBX,CAAhB,EAAmBD,IAAnB,GAA0Be,QAAQ,CAACP,CAAD,EAAIA,CAAC,CAACI,aAAF,CAAgBX,CAAhB,CAAJ,CAA5C;;AAEA,UAAIa,GAAG,GAAGN,CAAC,CAACI,aAAF,CAAgBX,CAAhB,EAAmBD,IAA7B,EAAmC;AACjCQ,QAAAA,CAAC,CAACI,aAAF,CAAgBX,CAAhB,EAAmBD,IAAnB,GAA0Bc,GAA1B;AACAN,QAAAA,CAAC,CAACI,aAAF,CAAgBX,CAAhB,EAAmBe,IAAnB,GAA0BR,CAA1B;AACD;AACF;AACF;;AAED,SAAOV,YAAP;AACD,C,CAED;;AACA,SAASiB,QAAT,CAAkBE,CAAlB,EAAqBC,CAArB,EAAwB;AACtB,SAAO,CAAP;AACD;;AAED,SAAST,WAAT,CAAqBV,KAArB,EAA4B;AAC1B,MAAIoB,GAAG,GAAGC,QAAV;AACA,MAAIC,MAAM,GAAG,CAAb;AACA,MAAIC,OAAO,GAAG,EAAd;;AAEA,OAAK,IAAIrB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,KAAK,CAACc,MAA1B,EAAkCZ,CAAC,EAAnC,EAAuC;AACrC,QAAIF,KAAK,CAACE,CAAD,CAAL,CAASD,IAAT,GAAgBmB,GAApB,EAAyB;AACvBA,MAAAA,GAAG,GAAGpB,KAAK,CAACE,CAAD,CAAL,CAASD,IAAf;AACAqB,MAAAA,MAAM,GAAGpB,CAAT;AACAqB,MAAAA,OAAO,GAAGvB,KAAK,CAACE,CAAD,CAAf;AACD;AACF;;AAEDF,EAAAA,KAAK,CAACwB,MAAN,CAAaF,MAAb,EAAqB,CAArB;AACA,SAAOC,OAAP;AACD","sourcesContent":["export function dikstrasAlgorithm(grid, startNode, endNode) {\n  let visitedNodes = [];\n\n  let queue = [];\n  startNode.dist = 0;\n  for (let i = 0; i < grid.maxRow; i++) {\n    for (let j = 0; j < grid.maxCol; j++) {\n      queue.push(grid.nodes[i][j]);\n    }\n  }\n\n  while (!queue.empty) {\n    let s = findMinimum(queue);\n    visitedNodes.push(s);\n\n    if (s.row == endNode.row && s.col == endNode.col) {\n      return visitedNodes;\n    }\n\n    for (let i = 0; i < s.adjacentNodes.length; i++) {\n      let alt = s.adjacentNodes[i].dist + distance(s, s.adjacentNodes[i]);\n\n      if (alt < s.adjacentNodes[i].dist) {\n        s.adjacentNodes[i].dist = alt;\n        s.adjacentNodes[i].prev = s;\n      }\n    }\n  }\n\n  return visitedNodes;\n}\n\n// change this when weights are implemented\nfunction distance(u, v) {\n  return 1;\n}\n\nfunction findMinimum(queue) {\n  let min = Infinity;\n  let minIdx = 0;\n  let minItem = {};\n\n  for (let i = 0; i < queue.length; i++) {\n    if (queue[i].dist < min) {\n      min = queue[i].dist;\n      minIdx = i;\n      minItem = queue[i];\n    }\n  }\n\n  queue.splice(minIdx, 1);\n  return minItem;\n}\n"]},"metadata":{},"sourceType":"module"}