{"ast":null,"code":"import*as constants from'../constants/constants';export default function astar(grid,startNode,endNode,numRows,numCols){var visitedNodes=[];var openList=[];var closedList=[];initialise(grid,numRows,numCols);openList.push(startNode);startNode.inOpenList=true;while(openList.length!==0){var currentNode=findLowestFCost(openList);if(currentNode===null){return{visitedNodes:visitedNodes,pathFound:false};}visitedNodes.push(currentNode);// End case -- result has been found, return the traced path\nif(currentNode.row===endNode.row&&currentNode.col===endNode.col){return{visitedNodes:visitedNodes,pathFound:true};}// Normal case -- move currentNode from open to closed, process each of its neighbours\nclosedList.push(currentNode);currentNode.inClosedList=true;for(var i=0;i<currentNode.adjacentNodes.length;i++){var adjacentRow=currentNode.adjacentNodes[i].row;var adjacentCol=currentNode.adjacentNodes[i].col;var neighbour=grid[adjacentRow][adjacentCol];if(neighbour.inClosedList||document.getElementById(\"node-\".concat(neighbour.row,\"-\").concat(neighbour.col)).className==='wall-node'){// not a valid node to process, skip to next neighbour\ncontinue;}// g score is the shortest distance from start to current node, we need to check if\n//   the path we have arrived at this neighbour is the shortest one we have seen yet\nvar neighbourDistance=1;if(document.getElementById(\"node-\".concat(neighbour.row,\"-\").concat(neighbour.col)).className==='weight-node'){neighbourDistance=constants.weightValue;}var gScore=currentNode.g+neighbourDistance;// 1 is the distance from a node to it's neighbour\nvar gScoreIsBest=false;if(!neighbour.inOpenList){// This the the first time we have arrived at this node, it must be the best\n// Also, we need to take the h (heuristic) score since we haven't done so yet\ngScoreIsBest=true;neighbour.h=heuristicValue(neighbour,endNode)*(1.0+0.001);// tiebreaker value added\nopenList.push(neighbour);neighbour.inOpenList=true;}else if(gScore<neighbour.g){// We have already seen the node, but last time it had a worse g (distance from start)\ngScoreIsBest=true;}if(gScoreIsBest){// Found an optimal (so far) path to this node.   Store info on how we got here and\n//  just how good it really is...\nneighbour.prev=currentNode;neighbour.g=gScore;neighbour.f=neighbour.g+neighbour.h;}}}// No result was found -- empty array signifies failure to find path\nreturn{visitedNodes:visitedNodes,pathFound:false};}function initialise(grid,numRows,numCols){for(var i=0;i<numRows;i++){for(var j=0;j<numCols;j++){var node=grid[i][j];node['f']=null;node['h']=null;node['g']=null;node['inOpenList']=false;node['inClosedList']=false;}}return grid;}function findLowestFCost(openList){var lowInd=0;for(var i=0;i<openList.length;i++){if(openList[i].f<openList[lowInd].f){lowInd=i;}}var minFNode=openList[lowInd];openList.splice(lowInd,1);minFNode.inOpenList=false;return minFNode;}function heuristicValue(pos0,pos1){var d1=Math.abs(pos1.row-pos0.row);var d2=Math.abs(pos1.col-pos0.col);return d1+d2;}","map":{"version":3,"sources":["/home/cristian/Documents/projects/visual_pathfinder/src/Algorithms/astar.js"],"names":["constants","astar","grid","startNode","endNode","numRows","numCols","visitedNodes","openList","closedList","initialise","push","inOpenList","length","currentNode","findLowestFCost","pathFound","row","col","inClosedList","i","adjacentNodes","adjacentRow","adjacentCol","neighbour","document","getElementById","className","neighbourDistance","weightValue","gScore","g","gScoreIsBest","h","heuristicValue","prev","f","j","node","lowInd","minFNode","splice","pos0","pos1","d1","Math","abs","d2"],"mappings":"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","sourcesContent":["import * as constants from '../constants/constants';\n\nexport default function astar(grid, startNode, endNode, numRows, numCols) {\n  let visitedNodes = [];\n  let openList = [];\n  let closedList = [];\n\n  initialise(grid, numRows, numCols);\n\n  openList.push(startNode);\n  startNode.inOpenList = true;\n\n  while (openList.length !== 0) {\n    let currentNode = findLowestFCost(openList);\n\n    if (currentNode === null) {\n      return { visitedNodes: visitedNodes, pathFound: false };\n    }\n\n    visitedNodes.push(currentNode);\n    // End case -- result has been found, return the traced path\n    if (currentNode.row === endNode.row && currentNode.col === endNode.col) {\n      return { visitedNodes: visitedNodes, pathFound: true };\n    }\n\n    // Normal case -- move currentNode from open to closed, process each of its neighbours\n    closedList.push(currentNode);\n    currentNode.inClosedList = true;\n    for (let i = 0; i < currentNode.adjacentNodes.length; i++) {\n      let adjacentRow = currentNode.adjacentNodes[i].row;\n      let adjacentCol = currentNode.adjacentNodes[i].col;\n\n      let neighbour = grid[adjacentRow][adjacentCol];\n\n      if (\n        neighbour.inClosedList ||\n        document.getElementById(`node-${neighbour.row}-${neighbour.col}`)\n          .className === 'wall-node'\n      ) {\n        // not a valid node to process, skip to next neighbour\n        continue;\n      }\n\n      // g score is the shortest distance from start to current node, we need to check if\n      //   the path we have arrived at this neighbour is the shortest one we have seen yet\n\n      let neighbourDistance = 1;\n      if (\n        document.getElementById(`node-${neighbour.row}-${neighbour.col}`)\n          .className === 'weight-node'\n      ) {\n        neighbourDistance = constants.weightValue;\n      }\n\n      let gScore = currentNode.g + neighbourDistance; // 1 is the distance from a node to it's neighbour\n\n      let gScoreIsBest = false;\n\n      if (!neighbour.inOpenList) {\n        // This the the first time we have arrived at this node, it must be the best\n        // Also, we need to take the h (heuristic) score since we haven't done so yet\n\n        gScoreIsBest = true;\n        neighbour.h = heuristicValue(neighbour, endNode) * (1.0 + 0.001); // tiebreaker value added\n        openList.push(neighbour);\n        neighbour.inOpenList = true;\n      } else if (gScore < neighbour.g) {\n        // We have already seen the node, but last time it had a worse g (distance from start)\n        gScoreIsBest = true;\n      }\n\n      if (gScoreIsBest) {\n        // Found an optimal (so far) path to this node.   Store info on how we got here and\n        //  just how good it really is...\n        neighbour.prev = currentNode;\n        neighbour.g = gScore;\n        neighbour.f = neighbour.g + neighbour.h;\n      }\n    }\n  }\n\n  // No result was found -- empty array signifies failure to find path\n  return { visitedNodes: visitedNodes, pathFound: false };\n}\n\nfunction initialise(grid, numRows, numCols) {\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numCols; j++) {\n      let node = grid[i][j];\n      node['f'] = null;\n      node['h'] = null;\n      node['g'] = null;\n      node['inOpenList'] = false;\n      node['inClosedList'] = false;\n    }\n  }\n\n  return grid;\n}\n\nfunction findLowestFCost(openList) {\n  let lowInd = 0;\n  for (let i = 0; i < openList.length; i++) {\n    if (openList[i].f < openList[lowInd].f) {\n      lowInd = i;\n    }\n  }\n  let minFNode = openList[lowInd];\n  openList.splice(lowInd, 1);\n  minFNode.inOpenList = false;\n  return minFNode;\n}\n\nfunction heuristicValue(pos0, pos1) {\n  let d1 = Math.abs(pos1.row - pos0.row);\n  let d2 = Math.abs(pos1.col - pos0.col);\n\n  return d1 + d2;\n}\n"]},"metadata":{},"sourceType":"module"}