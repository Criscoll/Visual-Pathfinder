{"ast":null,"code":"export default function astar(grid, startNode, endNode, numRows, numCols) {\n  let visitedNodes = [];\n  let openList = [];\n  let closedList = [];\n  initialise(grid, numRows, numCols);\n  openList.push(startNode);\n\n  while (openList.length !== 0) {\n    let currentNode = openList.findLowestFCost(openList);\n\n    if (Object.keys(node).length === 0) {\n      return {\n        visitedNodes: visitedNodes,\n        pathFound: false\n      };\n    }\n\n    visitedNodes.push(node);\n\n    if (node.row === endNode.row && node.col === endNode.col) {\n      return {\n        visitedNodes: visitedNodes,\n        pathFound: true\n      };\n    }\n\n    if (node.visited === false) {\n      node.visited = true;\n\n      for (let i = 0; i < node.adjacentNodes.length; i++) {\n        let adjacentRow = node.adjacentNodes[i].row;\n        let adjacentCol = node.adjacentNodes[i].col;\n\n        if (grid[adjacentRow][adjacentCol].visited === false && document.getElementById(`node-${adjacentRow}-${adjacentCol}`).className !== 'wall-node') {\n          stack.push(grid[adjacentRow][adjacentCol]);\n          grid[adjacentRow][adjacentCol].prev = node;\n        }\n      }\n    }\n  }\n\n  return {\n    visitedNodes: visitedNodes,\n    pathFound: false\n  };\n}\n\nfunction initialise(grid, numRows, numCols) {\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numCols; j++) {\n      let node = grid[i][j];\n      node['f'] = null;\n      node['h'] = null;\n      node['g'] = null;\n    }\n  }\n\n  return grid;\n}\n\nfunction findLowestFCost(openList) {\n  let lowInd = 0;\n\n  for (let i = 0; i < openList.length; i++) {\n    if (openList[i].f < openList[lowInd].f) {\n      lowInd = i;\n    }\n  }\n\n  return openList[lowInd];\n}\n\nfunction heuristicValue(pos0, pos1) {\n  let d1 = Math.abs(pos1.row - pos0.row);\n  let d2 = Math.abs(pos1.col - pos0.col);\n  return d1 + d2;\n}","map":{"version":3,"sources":["/home/cristian/Documents/projects/visual_pathfinder/src/Algorithms/astar.js"],"names":["astar","grid","startNode","endNode","numRows","numCols","visitedNodes","openList","closedList","initialise","push","length","currentNode","findLowestFCost","Object","keys","node","pathFound","row","col","visited","i","adjacentNodes","adjacentRow","adjacentCol","document","getElementById","className","stack","prev","j","lowInd","f","heuristicValue","pos0","pos1","d1","Math","abs","d2"],"mappings":"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","sourcesContent":["export default function astar(grid, startNode, endNode, numRows, numCols) {\n  let visitedNodes = [];\n  let openList = [];\n  let closedList = [];\n\n  initialise(grid, numRows, numCols);\n\n  openList.push(startNode);\n\n  while (openList.length !== 0) {\n    let currentNode = openList.findLowestFCost(openList);\n\n    if (Object.keys(node).length === 0) {\n      return { visitedNodes: visitedNodes, pathFound: false };\n    }\n\n    visitedNodes.push(node);\n\n    if (node.row === endNode.row && node.col === endNode.col) {\n      return { visitedNodes: visitedNodes, pathFound: true };\n    }\n\n    if (node.visited === false) {\n      node.visited = true;\n\n      for (let i = 0; i < node.adjacentNodes.length; i++) {\n        let adjacentRow = node.adjacentNodes[i].row;\n        let adjacentCol = node.adjacentNodes[i].col;\n\n        if (\n          grid[adjacentRow][adjacentCol].visited === false &&\n          document.getElementById(`node-${adjacentRow}-${adjacentCol}`)\n            .className !== 'wall-node'\n        ) {\n          stack.push(grid[adjacentRow][adjacentCol]);\n          grid[adjacentRow][adjacentCol].prev = node;\n        }\n      }\n    }\n  }\n  return { visitedNodes: visitedNodes, pathFound: false };\n}\n\nfunction initialise(grid, numRows, numCols) {\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numCols; j++) {\n      let node = grid[i][j];\n      node['f'] = null;\n      node['h'] = null;\n      node['g'] = null;\n    }\n  }\n\n  return grid;\n}\n\nfunction findLowestFCost(openList) {\n  let lowInd = 0;\n  for (let i = 0; i < openList.length; i++) {\n    if (openList[i].f < openList[lowInd].f) {\n      lowInd = i;\n    }\n  }\n  return openList[lowInd];\n}\n\nfunction heuristicValue(pos0, pos1) {\n  let d1 = Math.abs(pos1.row - pos0.row);\n  let d2 = Math.abs(pos1.col - pos0.col);\n\n  return d1 + d2;\n}\n"]},"metadata":{},"sourceType":"module"}