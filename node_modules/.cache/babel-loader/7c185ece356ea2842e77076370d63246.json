{"ast":null,"code":"export default function dikstrasAlgorithm(grid, startNode, endNode, numRows, numCols, pathFound) {\n  let visitedNodes = [];\n  let queue = [];\n  startNode.dist = 0;\n\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numCols; j++) {\n      if (grid[i][j].nodeType !== \"wall-node\") {\n        queue.push(grid[i][j]);\n      }\n    }\n  }\n\n  while (queue.length !== 0) {\n    console.log(queue.length);\n    let s = findMinimum(queue);\n\n    if (Object.keys(s).length === 0) {\n      return visitedNodes;\n      pathFound = false;\n    }\n\n    visitedNodes.push(s);\n\n    if (s.row === endNode.row && s.col === endNode.col) {\n      return visitedNodes;\n    }\n\n    console.log(s);\n\n    for (let i = 0; i < s.adjacentNodes.length; i++) {\n      if (s.adjacentNodes[i].nodeType !== \"wall-node\") {\n        let alt = s.dist + distance(s, s.adjacentNodes[i]);\n\n        if (alt < s.adjacentNodes[i].dist) {\n          s.adjacentNodes[i].dist = alt;\n          s.adjacentNodes[i].prev = s;\n        }\n      }\n    }\n  }\n\n  pathFound = false;\n  return visitedNodes;\n} // change this when weights are implemented\n\nfunction distance(u, v) {\n  return 1;\n}\n\nfunction findMinimum(queue) {\n  let min = Infinity;\n  let minIdx = 0;\n  let minItem = {};\n\n  for (let i = 0; i < queue.length; i++) {\n    if (queue[i].dist < min) {\n      min = queue[i].dist;\n      minIdx = i;\n      minItem = queue[i];\n    }\n  }\n\n  queue.splice(minIdx, 1);\n  return minItem;\n}","map":{"version":3,"sources":["/home/cristian/Documents/projects/visual_pathfinder/my-app/src/Algorithms/dijkstras.js"],"names":["dikstrasAlgorithm","grid","startNode","endNode","numRows","numCols","pathFound","visitedNodes","queue","dist","i","j","nodeType","push","length","console","log","s","findMinimum","Object","keys","row","col","adjacentNodes","alt","distance","prev","u","v","min","Infinity","minIdx","minItem","splice"],"mappings":"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","sourcesContent":["export default function dikstrasAlgorithm(\n  grid,\n  startNode,\n  endNode,\n  numRows,\n  numCols,\n  pathFound\n) {\n  let visitedNodes = [];\n\n  let queue = [];\n  startNode.dist = 0;\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numCols; j++) {\n      if (grid[i][j].nodeType !== \"wall-node\") {\n        queue.push(grid[i][j]);\n      }\n    }\n  }\n\n  while (queue.length !== 0) {\n    console.log(queue.length);\n    let s = findMinimum(queue);\n\n    if (Object.keys(s).length === 0) {\n      return visitedNodes;\n      pathFound = false;\n    }\n\n    visitedNodes.push(s);\n\n    if (s.row === endNode.row && s.col === endNode.col) {\n      return visitedNodes;\n    }\n\n    console.log(s);\n\n    for (let i = 0; i < s.adjacentNodes.length; i++) {\n      if (s.adjacentNodes[i].nodeType !== \"wall-node\") {\n        let alt = s.dist + distance(s, s.adjacentNodes[i]);\n        if (alt < s.adjacentNodes[i].dist) {\n          s.adjacentNodes[i].dist = alt;\n          s.adjacentNodes[i].prev = s;\n        }\n      }\n    }\n  }\n\n  pathFound = false;\n  return visitedNodes;\n}\n\n// change this when weights are implemented\nfunction distance(u, v) {\n  return 1;\n}\n\nfunction findMinimum(queue) {\n  let min = Infinity;\n  let minIdx = 0;\n  let minItem = {};\n\n  for (let i = 0; i < queue.length; i++) {\n    if (queue[i].dist < min) {\n      min = queue[i].dist;\n      minIdx = i;\n      minItem = queue[i];\n    }\n  }\n\n  queue.splice(minIdx, 1);\n  return minItem;\n}\n"]},"metadata":{},"sourceType":"module"}