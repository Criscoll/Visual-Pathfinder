{"ast":null,"code":"import * as constants from '../constants/constants';\nexport default function recursiveDivision(origin, width, height, timer) {\n  // Recursion termination\n  if (width < 2 || height < 2) {\n    return;\n  }\n\n  let isHorizontal = Boolean(width < height);\n\n  if (width === height) {\n    isHorizontal = randomIntFromInterval(0, 100) > 50;\n  } // let isHorizontal = 0;\n\n\n  let wallIdx = isHorizontal ? randomIntFromInterval(origin.row + 1, height + origin.row - 2) : randomIntFromInterval(origin.col + 1, width + origin.col - 2);\n  const wallHole = isHorizontal ? Math.floor(Math.random() * (width - 1)) + origin.col : Math.floor(Math.random() * (height - 1)) + origin.row; // console.log(origin);\n  // console.log(`wallIdx: ${wallIdx}, height: ${height}`);\n\n  if (isHorizontal) {\n    if (wallIdx >= constants.maxRow) {\n      return;\n    }\n\n    timer = buildHorizontalWall(origin, wallIdx, width, timer);\n    recursiveDivision(origin, width, Math.abs(wallIdx - origin.row), timer);\n    recursiveDivision({\n      row: wallIdx + 1,\n      col: origin.col\n    }, width, height - wallIdx - 1, timer);\n  } else {\n    if (wallIdx >= constants.maxCol) {\n      return;\n    }\n\n    timer = buildVerticalWall(origin, wallIdx, height, timer);\n    recursiveDivision(origin, Math.abs(wallIdx - origin.col), height, timer);\n    recursiveDivision({\n      row: origin.row,\n      col: wallIdx + 1\n    }, width - wallIdx - 1, height, timer);\n  }\n}\n\nfunction randomIntFromInterval(min, max) {\n  // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction buildHorizontalWall(origin, wallIdx, width, timer) {\n  for (let col = origin.col; col < width + origin.col; col++) {\n    if (!['start-node', 'end-node'].includes(document.getElementById(`node-${wallIdx}-${col}`).className) && col !== wallHole) {\n      setTimeout(() => {\n        document.getElementById(`node-${wallIdx}-${col}`).className = 'wall-node';\n      }, 50 * timer);\n      timer++;\n    }\n  }\n\n  return timer;\n}\n\nfunction buildVerticalWall(origin, wallIdx, height, timer) {\n  for (let row = origin.row; row < height + origin.row; row++) {\n    if (!['start-node', 'end-node'].includes(document.getElementById(`node-${row}-${wallIdx}`).className) && row !== wallHole) {\n      setTimeout(() => {\n        document.getElementById(`node-${row}-${wallIdx}`).className = 'wall-node';\n      }, 50 * timer);\n      timer++;\n    }\n  }\n\n  return timer;\n}","map":{"version":3,"sources":["/home/cristian/Documents/projects/visual_pathfinder/src/Algorithms/recursiveDivision.js"],"names":["constants","recursiveDivision","origin","width","height","timer","isHorizontal","Boolean","randomIntFromInterval","wallIdx","row","col","wallHole","Math","floor","random","maxRow","buildHorizontalWall","abs","maxCol","buildVerticalWall","min","max","includes","document","getElementById","className","setTimeout"],"mappings":"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","sourcesContent":["import * as constants from '../constants/constants';\n\nexport default function recursiveDivision(origin, width, height, timer) {\n  // Recursion termination\n  if (width < 2 || height < 2) {\n    return;\n  }\n\n  let isHorizontal = Boolean(width < height);\n  if (width === height) {\n    isHorizontal = randomIntFromInterval(0, 100) > 50;\n  }\n  // let isHorizontal = 0;\n\n  let wallIdx = isHorizontal\n    ? randomIntFromInterval(origin.row + 1, height + origin.row - 2)\n    : randomIntFromInterval(origin.col + 1, width + origin.col - 2);\n\n  const wallHole = isHorizontal\n    ? Math.floor(Math.random() * (width - 1)) + origin.col\n    : Math.floor(Math.random() * (height - 1)) + origin.row;\n  // console.log(origin);\n  // console.log(`wallIdx: ${wallIdx}, height: ${height}`);\n\n  if (isHorizontal) {\n    if (wallIdx >= constants.maxRow) {\n      return;\n    }\n    timer = buildHorizontalWall(origin, wallIdx, width, timer);\n    recursiveDivision(origin, width, Math.abs(wallIdx - origin.row), timer);\n    recursiveDivision(\n      { row: wallIdx + 1, col: origin.col },\n      width,\n      height - wallIdx - 1,\n      timer\n    );\n  } else {\n    if (wallIdx >= constants.maxCol) {\n      return;\n    }\n    timer = buildVerticalWall(origin, wallIdx, height, timer);\n    recursiveDivision(origin, Math.abs(wallIdx - origin.col), height, timer);\n    recursiveDivision(\n      { row: origin.row, col: wallIdx + 1 },\n      width - wallIdx - 1,\n      height,\n      timer\n    );\n  }\n}\n\nfunction randomIntFromInterval(min, max) {\n  // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction buildHorizontalWall(origin, wallIdx, width, timer) {\n  for (let col = origin.col; col < width + origin.col; col++) {\n    if (\n      !['start-node', 'end-node'].includes(\n        document.getElementById(`node-${wallIdx}-${col}`).className\n      ) &&\n      col !== wallHole\n    ) {\n      setTimeout(() => {\n        document.getElementById(`node-${wallIdx}-${col}`).className =\n          'wall-node';\n      }, 50 * timer);\n      timer++;\n    }\n  }\n  return timer;\n}\n\nfunction buildVerticalWall(origin, wallIdx, height, timer) {\n  for (let row = origin.row; row < height + origin.row; row++) {\n    if (\n      !['start-node', 'end-node'].includes(\n        document.getElementById(`node-${row}-${wallIdx}`).className\n      ) &&\n      row !== wallHole\n    ) {\n      setTimeout(() => {\n        document.getElementById(`node-${row}-${wallIdx}`).className =\n          'wall-node';\n      }, 50 * timer);\n      timer++;\n    }\n  }\n  return timer;\n}\n"]},"metadata":{},"sourceType":"module"}