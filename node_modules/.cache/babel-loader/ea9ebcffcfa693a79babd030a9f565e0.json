{"ast":null,"code":"import * as constants from '../constants/constants';\nexport default function recursiveDivision(origin, width, height, wallInfo, timer, withWeight) {\n  // Recursion termination\n  if (width < 2 || height < 2) {\n    console.log(origin);\n    console.log(`width: ${width}, height: ${height}`);\n    return timer;\n  }\n\n  let isHorizontal = Boolean(width < height);\n\n  if (width === height) {\n    isHorizontal = randomIntFromInterval(0, 100) > 50;\n  } // let isHorizontal = 0;\n\n\n  let wallIdx = isHorizontal ? randomIntFromInterval(origin.row + 1, height + origin.row - 2) : randomIntFromInterval(origin.col + 1, width + origin.col - 2);\n\n  while (wallIdx % 2 === 0) {\n    wallIdx = isHorizontal ? randomIntFromInterval(origin.row + 1, height + origin.row - 2) : randomIntFromInterval(origin.col + 1, width + origin.col - 2);\n  }\n\n  let holeIdx = isHorizontal ? Math.floor(Math.random() * (width - 1)) + origin.col : Math.floor(Math.random() * (height - 1)) + origin.row;\n\n  while (holeIdx % 2 === 1) {\n    holeIdx = isHorizontal ? Math.floor(Math.random() * (width - 1)) + origin.col : Math.floor(Math.random() * (height - 1)) + origin.row;\n  }\n\n  wallInfo.isHorizontal = isHorizontal;\n  wallInfo.holeIdx = holeIdx;\n  let mazeDelay;\n\n  if (isHorizontal) {\n    if (wallIdx >= constants.maxRow) {\n      return;\n    }\n\n    timer = buildHorizontalWall(origin, wallIdx, wallInfo, width, timer, withWeight);\n    let mazeDelayOne = recursiveDivision(origin, width, Math.abs(wallIdx - origin.row), wallInfo, timer, withWeight);\n    let mazeDelayTwo = recursiveDivision({\n      row: wallIdx + 1,\n      col: origin.col\n    }, width, height + origin.row - wallIdx - 1, wallInfo, timer, withWeight);\n    mazeDelay = mazeDelayOne > mazeDelayTwo ? mazeDelayOne : mazeDelayTwo;\n  } else {\n    if (wallIdx >= constants.maxCol) {\n      return;\n    }\n\n    timer = buildVerticalWall(origin, wallIdx, wallInfo, height, timer, withWeight);\n    let mazeDelayOne = recursiveDivision(origin, Math.abs(wallIdx - origin.col), height, wallInfo, timer, withWeight);\n    let mazeDelayTwo = recursiveDivision({\n      row: origin.row,\n      col: wallIdx + 1\n    }, width + origin.col - wallIdx - 1, height, wallInfo, timer, withWeight);\n    mazeDelay = mazeDelayOne > mazeDelayTwo ? mazeDelayOne : mazeDelayTwo;\n  }\n\n  return mazeDelay;\n}\n\nfunction randomIntFromInterval(min, max) {\n  // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction buildHorizontalWall(origin, wallIdx, wallInfo, width, timer, withWeight) {\n  for (let col = origin.col; col < width + origin.col; col++) {\n    if (!['start-node', 'end-node'].includes(document.getElementById(`node-${wallIdx}-${col}`).className) && col !== wallInfo.holeIdx) {\n      setTimeout(() => {\n        if (withWeight && Math.floor(Math.random() * 100) > 82 && col % 2 === 1) {\n          document.getElementById(`node-${wallIdx}-${col}`).className = 'weight-node';\n        } else {\n          document.getElementById(`node-${wallIdx}-${col}`).className = 'wall-node';\n        }\n      }, 70 * timer);\n      timer++;\n    }\n  }\n\n  return timer;\n}\n\nfunction buildVerticalWall(origin, wallIdx, wallInfo, height, timer, withWeight) {\n  for (let row = origin.row; row < height + origin.row; row++) {\n    if (!['start-node', 'end-node'].includes(document.getElementById(`node-${row}-${wallIdx}`).className) && row !== wallInfo.holeIdx) {\n      setTimeout(() => {\n        if (withWeight && Math.floor(Math.random() * 100) > 82 && row % 2 === 1) {\n          document.getElementById(`node-${row}-${wallIdx}`).className = 'weight-node';\n        } else {\n          document.getElementById(`node-${row}-${wallIdx}`).className = 'wall-node';\n        }\n      }, 70 * timer);\n      timer++;\n    }\n  }\n\n  return timer;\n}","map":{"version":3,"sources":["/home/cristian/Documents/projects/visual_pathfinder/src/Algorithms/recursiveDivision.js"],"names":["constants","recursiveDivision","origin","width","height","wallInfo","timer","withWeight","console","log","isHorizontal","Boolean","randomIntFromInterval","wallIdx","row","col","holeIdx","Math","floor","random","mazeDelay","maxRow","buildHorizontalWall","mazeDelayOne","abs","mazeDelayTwo","maxCol","buildVerticalWall","min","max","includes","document","getElementById","className","setTimeout"],"mappings":"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","sourcesContent":["import * as constants from '../constants/constants';\n\nexport default function recursiveDivision(\n  origin,\n  width,\n  height,\n  wallInfo,\n  timer,\n  withWeight\n) {\n  // Recursion termination\n  if (width < 2 || height < 2) {\n    console.log(origin);\n    console.log(`width: ${width}, height: ${height}`);\n    return timer;\n  }\n\n  let isHorizontal = Boolean(width < height);\n  if (width === height) {\n    isHorizontal = randomIntFromInterval(0, 100) > 50;\n  }\n  // let isHorizontal = 0;\n\n  let wallIdx = isHorizontal\n    ? randomIntFromInterval(origin.row + 1, height + origin.row - 2)\n    : randomIntFromInterval(origin.col + 1, width + origin.col - 2);\n\n  while (wallIdx % 2 === 0) {\n    wallIdx = isHorizontal\n      ? randomIntFromInterval(origin.row + 1, height + origin.row - 2)\n      : randomIntFromInterval(origin.col + 1, width + origin.col - 2);\n  }\n\n  let holeIdx = isHorizontal\n    ? Math.floor(Math.random() * (width - 1)) + origin.col\n    : Math.floor(Math.random() * (height - 1)) + origin.row;\n\n  while (holeIdx % 2 === 1) {\n    holeIdx = isHorizontal\n      ? Math.floor(Math.random() * (width - 1)) + origin.col\n      : Math.floor(Math.random() * (height - 1)) + origin.row;\n  }\n  wallInfo.isHorizontal = isHorizontal;\n  wallInfo.holeIdx = holeIdx;\n\n  let mazeDelay;\n  if (isHorizontal) {\n    if (wallIdx >= constants.maxRow) {\n      return;\n    }\n    timer = buildHorizontalWall(\n      origin,\n      wallIdx,\n      wallInfo,\n      width,\n      timer,\n      withWeight\n    );\n    let mazeDelayOne = recursiveDivision(\n      origin,\n      width,\n      Math.abs(wallIdx - origin.row),\n      wallInfo,\n      timer,\n      withWeight\n    );\n    let mazeDelayTwo = recursiveDivision(\n      { row: wallIdx + 1, col: origin.col },\n      width,\n      height + origin.row - wallIdx - 1,\n      wallInfo,\n      timer,\n      withWeight\n    );\n\n    mazeDelay = mazeDelayOne > mazeDelayTwo ? mazeDelayOne : mazeDelayTwo;\n  } else {\n    if (wallIdx >= constants.maxCol) {\n      return;\n    }\n    timer = buildVerticalWall(\n      origin,\n      wallIdx,\n      wallInfo,\n      height,\n      timer,\n      withWeight\n    );\n    let mazeDelayOne = recursiveDivision(\n      origin,\n      Math.abs(wallIdx - origin.col),\n      height,\n      wallInfo,\n      timer,\n      withWeight\n    );\n    let mazeDelayTwo = recursiveDivision(\n      { row: origin.row, col: wallIdx + 1 },\n      width + origin.col - wallIdx - 1,\n      height,\n      wallInfo,\n      timer,\n      withWeight\n    );\n\n    mazeDelay = mazeDelayOne > mazeDelayTwo ? mazeDelayOne : mazeDelayTwo;\n  }\n\n  return mazeDelay;\n}\n\nfunction randomIntFromInterval(min, max) {\n  // min and max included\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n\nfunction buildHorizontalWall(\n  origin,\n  wallIdx,\n  wallInfo,\n  width,\n  timer,\n  withWeight\n) {\n  for (let col = origin.col; col < width + origin.col; col++) {\n    if (\n      !['start-node', 'end-node'].includes(\n        document.getElementById(`node-${wallIdx}-${col}`).className\n      ) &&\n      col !== wallInfo.holeIdx\n    ) {\n      setTimeout(() => {\n        if (\n          withWeight &&\n          Math.floor(Math.random() * 100) > 82 &&\n          col % 2 === 1\n        ) {\n          document.getElementById(`node-${wallIdx}-${col}`).className =\n            'weight-node';\n        } else {\n          document.getElementById(`node-${wallIdx}-${col}`).className =\n            'wall-node';\n        }\n      }, 70 * timer);\n      timer++;\n    }\n  }\n\n  return timer;\n}\n\nfunction buildVerticalWall(\n  origin,\n  wallIdx,\n  wallInfo,\n  height,\n  timer,\n  withWeight\n) {\n  for (let row = origin.row; row < height + origin.row; row++) {\n    if (\n      !['start-node', 'end-node'].includes(\n        document.getElementById(`node-${row}-${wallIdx}`).className\n      ) &&\n      row !== wallInfo.holeIdx\n    ) {\n      setTimeout(() => {\n        if (\n          withWeight &&\n          Math.floor(Math.random() * 100) > 82 &&\n          row % 2 === 1\n        ) {\n          document.getElementById(`node-${row}-${wallIdx}`).className =\n            'weight-node';\n        } else {\n          document.getElementById(`node-${row}-${wallIdx}`).className =\n            'wall-node';\n        }\n      }, 70 * timer);\n      timer++;\n    }\n  }\n\n  return timer;\n}\n"]},"metadata":{},"sourceType":"module"}