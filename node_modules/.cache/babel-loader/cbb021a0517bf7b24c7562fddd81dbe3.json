{"ast":null,"code":"export default function astar(grid, startNode, endNode, numRows, numCols) {\n  let visitedNodes = [];\n  let openList = [];\n  let closedList = [];\n  initialise(grid, numRows, numCols);\n  openList.push(startNode);\n  startNode.inOpenList = true;\n  let i = 0;\n\n  while (openList.length !== 0) {\n    i++;\n    let currentNode = findLowestFCost(openList);\n\n    if (currentNode === null) {\n      return {\n        visitedNodes: visitedNodes,\n        pathFound: false\n      };\n    }\n\n    visitedNodes.push(currentNode); // End case -- result has been found, return the traced path\n\n    if (currentNode.row === endNode.row && currentNode.col === endNode.col) {\n      return {\n        visitedNodes: visitedNodes,\n        pathFound: true\n      };\n    } // Normal case -- move currentNode from open to closed, process each of its neighbours\n\n\n    closedList.push(currentNode);\n    currentNode.inClosedList = true;\n\n    for (let i = 0; i < currentNode.adjacentNodes.length; i++) {\n      let adjacentRow = currentNode.adjacentNodes[i].row;\n      let adjacentCol = currentNode.adjacentNodes[i].col;\n      let neighbour = grid[adjacentRow][adjacentCol];\n\n      if (neighbour.inClosedList || document.getElementById(`node-${neighbour.row}-${neighbour.col}`).className === 'wall-node') {\n        // not a valid node to process, skip to next neighbour\n        continue;\n      } // g score is the shortest distance from start to current node, we need to check if\n      //   the path we have arrived at this neighbour is the shortest one we have seen yet\n\n\n      let neighbourDistance = 1;\n\n      if (document.getElementById(`node-${neighbour.row}-${neighbour.col}`).className === 'weight-node') {\n        neighbourDistance = 15;\n      }\n\n      let gScore = currentNode.g + neighbourDistance; // 1 is the distance from a node to it's neighbour\n\n      let gScoreIsBest = false;\n\n      if (!neighbour.inOpenList) {\n        // This the the first time we have arrived at this node, it must be the best\n        // Also, we need to take the h (heuristic) score since we haven't done so yet\n        gScoreIsBest = true;\n        neighbour.h = heuristicValue(neighbour, endNode) * (1.0 + 0.001); // tiebreaker value added\n\n        openList.push(neighbour);\n        neighbour.inOpenList = true;\n      } else if (gScore < neighbour.g) {\n        // We have already seen the node, but last time it had a worse g (distance from start)\n        gScoreIsBest = true;\n      }\n\n      if (gScoreIsBest) {\n        // Found an optimal (so far) path to this node.   Store info on how we got here and\n        //  just how good it really is...\n        neighbour.prev = currentNode;\n        neighbour.g = gScore;\n        neighbour.f = neighbour.g + neighbour.h;\n      }\n    }\n  } // No result was found -- empty array signifies failure to find path\n\n\n  return {\n    visitedNodes: visitedNodes,\n    pathFound: false\n  };\n}\n\nfunction initialise(grid, numRows, numCols) {\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numCols; j++) {\n      let node = grid[i][j];\n      node['f'] = null;\n      node['h'] = null;\n      node['g'] = null;\n      node['inOpenList'] = false;\n      node['inClosedList'] = false;\n    }\n  }\n\n  return grid;\n}\n\nfunction findLowestFCost(openList) {\n  let lowInd = 0;\n\n  for (let i = 0; i < openList.length; i++) {\n    if (openList[i].f < openList[lowInd].f) {\n      lowInd = i;\n    }\n  }\n\n  let minFNode = openList[lowInd];\n  openList.splice(lowInd, 1);\n  minFNode.inOpenList = false;\n  return minFNode;\n}\n\nfunction heuristicValue(pos0, pos1) {\n  let d1 = Math.abs(pos1.row - pos0.row);\n  let d2 = Math.abs(pos1.col - pos0.col);\n  return d1 + d2;\n}","map":{"version":3,"sources":["/home/cristian/Documents/projects/visual_pathfinder/src/Algorithms/astar.js"],"names":["astar","grid","startNode","endNode","numRows","numCols","visitedNodes","openList","closedList","initialise","push","inOpenList","i","length","currentNode","findLowestFCost","pathFound","row","col","inClosedList","adjacentNodes","adjacentRow","adjacentCol","neighbour","document","getElementById","className","neighbourDistance","gScore","g","gScoreIsBest","h","heuristicValue","prev","f","j","node","lowInd","minFNode","splice","pos0","pos1","d1","Math","abs","d2"],"mappings":"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","sourcesContent":["export default function astar(grid, startNode, endNode, numRows, numCols) {\n  let visitedNodes = [];\n  let openList = [];\n  let closedList = [];\n\n  initialise(grid, numRows, numCols);\n\n  openList.push(startNode);\n  startNode.inOpenList = true;\n\n  let i = 0;\n\n  while (openList.length !== 0) {\n    i++;\n\n    let currentNode = findLowestFCost(openList);\n\n    if (currentNode === null) {\n      return { visitedNodes: visitedNodes, pathFound: false };\n    }\n\n    visitedNodes.push(currentNode);\n    // End case -- result has been found, return the traced path\n    if (currentNode.row === endNode.row && currentNode.col === endNode.col) {\n      return { visitedNodes: visitedNodes, pathFound: true };\n    }\n\n    // Normal case -- move currentNode from open to closed, process each of its neighbours\n    closedList.push(currentNode);\n    currentNode.inClosedList = true;\n    for (let i = 0; i < currentNode.adjacentNodes.length; i++) {\n      let adjacentRow = currentNode.adjacentNodes[i].row;\n      let adjacentCol = currentNode.adjacentNodes[i].col;\n\n      let neighbour = grid[adjacentRow][adjacentCol];\n\n      if (\n        neighbour.inClosedList ||\n        document.getElementById(`node-${neighbour.row}-${neighbour.col}`)\n          .className === 'wall-node'\n      ) {\n        // not a valid node to process, skip to next neighbour\n        continue;\n      }\n\n      // g score is the shortest distance from start to current node, we need to check if\n      //   the path we have arrived at this neighbour is the shortest one we have seen yet\n\n      let neighbourDistance = 1;\n      if (\n        document.getElementById(`node-${neighbour.row}-${neighbour.col}`)\n          .className === 'weight-node'\n      ) {\n        neighbourDistance = 15;\n      }\n\n      let gScore = currentNode.g + neighbourDistance; // 1 is the distance from a node to it's neighbour\n\n      let gScoreIsBest = false;\n\n      if (!neighbour.inOpenList) {\n        // This the the first time we have arrived at this node, it must be the best\n        // Also, we need to take the h (heuristic) score since we haven't done so yet\n\n        gScoreIsBest = true;\n        neighbour.h = heuristicValue(neighbour, endNode) * (1.0 + 0.001); // tiebreaker value added\n        openList.push(neighbour);\n        neighbour.inOpenList = true;\n      } else if (gScore < neighbour.g) {\n        // We have already seen the node, but last time it had a worse g (distance from start)\n        gScoreIsBest = true;\n      }\n\n      if (gScoreIsBest) {\n        // Found an optimal (so far) path to this node.   Store info on how we got here and\n        //  just how good it really is...\n        neighbour.prev = currentNode;\n        neighbour.g = gScore;\n        neighbour.f = neighbour.g + neighbour.h;\n      }\n    }\n  }\n\n  // No result was found -- empty array signifies failure to find path\n  return { visitedNodes: visitedNodes, pathFound: false };\n}\n\nfunction initialise(grid, numRows, numCols) {\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numCols; j++) {\n      let node = grid[i][j];\n      node['f'] = null;\n      node['h'] = null;\n      node['g'] = null;\n      node['inOpenList'] = false;\n      node['inClosedList'] = false;\n    }\n  }\n\n  return grid;\n}\n\nfunction findLowestFCost(openList) {\n  let lowInd = 0;\n  for (let i = 0; i < openList.length; i++) {\n    if (openList[i].f < openList[lowInd].f) {\n      lowInd = i;\n    }\n  }\n  let minFNode = openList[lowInd];\n  openList.splice(lowInd, 1);\n  minFNode.inOpenList = false;\n  return minFNode;\n}\n\nfunction heuristicValue(pos0, pos1) {\n  let d1 = Math.abs(pos1.row - pos0.row);\n  let d2 = Math.abs(pos1.col - pos0.col);\n\n  return d1 + d2;\n}\n"]},"metadata":{},"sourceType":"module"}