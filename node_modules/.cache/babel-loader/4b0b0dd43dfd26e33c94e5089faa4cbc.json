{"ast":null,"code":"import * as constants from '../constants/constants';\nexport default function dikstrasAlgorithm(grid, startNode, endNode, numRows, numCols) {\n  let visitedNodes = [];\n  let queue = [];\n  startNode.dist = 0;\n\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numCols; j++) {\n      if (document.getElementById(`node-${i}-${j}`).className !== 'wall-node') {\n        queue.push(grid[i][j]);\n      }\n    }\n  }\n\n  while (queue.length !== 0) {\n    let s = findMinimum(queue);\n\n    if (Object.keys(s).length === 0) {\n      return {\n        visitedNodes: visitedNodes,\n        pathFound: false\n      };\n    }\n\n    visitedNodes.push(s);\n\n    if (s.row === endNode.row && s.col === endNode.col) {\n      return {\n        visitedNodes: visitedNodes,\n        pathFound: true\n      };\n    }\n\n    for (let i = 0; i < s.adjacentNodes.length; i++) {\n      if (document.getElementById(`node-${s.adjacentNodes[i].row}-${s.adjacentNodes[i].col}`).className !== 'wall-node') {\n        let adjacentRow = s.adjacentNodes[i].row;\n        let adjacentCol = s.adjacentNodes[i].col;\n        let alt = s.dist + distance(s, s.adjacentNodes[i]);\n\n        if (alt < grid[adjacentRow][adjacentCol].dist) {\n          grid[adjacentRow][adjacentCol].dist = alt;\n          grid[adjacentRow][adjacentCol].prev = s;\n        }\n      }\n    }\n  }\n\n  return {\n    visitedNodes: visitedNodes,\n    pathFound: false\n  };\n} // change this when weights are implemented\n\nfunction distance(u, v) {\n  if (document.getElementById(`node-${v.row}-${v.col}`).className == 'weight-node') {\n    return constants.weightValue;\n  } else {\n    return 1;\n  }\n}\n\nfunction findMinimum(queue) {\n  let min = Infinity;\n  let minIdx = 0;\n  let minItem = {};\n\n  for (let i = 0; i < queue.length; i++) {\n    if (queue[i].dist < min) {\n      min = queue[i].dist;\n      minIdx = i;\n      minItem = queue[i];\n    }\n  }\n\n  queue.splice(minIdx, 1);\n  return minItem;\n}","map":{"version":3,"sources":["/home/cristian/Documents/projects/visual_pathfinder/src/Algorithms/dijkstras.js"],"names":["constants","dikstrasAlgorithm","grid","startNode","endNode","numRows","numCols","visitedNodes","queue","dist","i","j","document","getElementById","className","push","length","s","findMinimum","Object","keys","pathFound","row","col","adjacentNodes","adjacentRow","adjacentCol","alt","distance","prev","u","v","weightValue","min","Infinity","minIdx","minItem","splice"],"mappings":"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","sourcesContent":["import * as constants from '../constants/constants';\n\nexport default function dikstrasAlgorithm(\n  grid,\n  startNode,\n  endNode,\n  numRows,\n  numCols\n) {\n  let visitedNodes = [];\n  let queue = [];\n\n  startNode.dist = 0;\n  for (let i = 0; i < numRows; i++) {\n    for (let j = 0; j < numCols; j++) {\n      if (document.getElementById(`node-${i}-${j}`).className !== 'wall-node') {\n        queue.push(grid[i][j]);\n      }\n    }\n  }\n\n  while (queue.length !== 0) {\n    let s = findMinimum(queue);\n\n    if (Object.keys(s).length === 0) {\n      return { visitedNodes: visitedNodes, pathFound: false };\n    }\n\n    visitedNodes.push(s);\n\n    if (s.row === endNode.row && s.col === endNode.col) {\n      return { visitedNodes: visitedNodes, pathFound: true };\n    }\n\n    for (let i = 0; i < s.adjacentNodes.length; i++) {\n      if (\n        document.getElementById(\n          `node-${s.adjacentNodes[i].row}-${s.adjacentNodes[i].col}`\n        ).className !== 'wall-node'\n      ) {\n        let adjacentRow = s.adjacentNodes[i].row;\n        let adjacentCol = s.adjacentNodes[i].col;\n        let alt = s.dist + distance(s, s.adjacentNodes[i]);\n\n        if (alt < grid[adjacentRow][adjacentCol].dist) {\n          grid[adjacentRow][adjacentCol].dist = alt;\n          grid[adjacentRow][adjacentCol].prev = s;\n        }\n      }\n    }\n  }\n\n  return { visitedNodes: visitedNodes, pathFound: false };\n}\n\n// change this when weights are implemented\nfunction distance(u, v) {\n  if (\n    document.getElementById(`node-${v.row}-${v.col}`).className == 'weight-node'\n  ) {\n    return constants.weightValue;\n  } else {\n    return 1;\n  }\n}\n\nfunction findMinimum(queue) {\n  let min = Infinity;\n  let minIdx = 0;\n  let minItem = {};\n\n  for (let i = 0; i < queue.length; i++) {\n    if (queue[i].dist < min) {\n      min = queue[i].dist;\n      minIdx = i;\n      minItem = queue[i];\n    }\n  }\n\n  queue.splice(minIdx, 1);\n  return minItem;\n}\n"]},"metadata":{},"sourceType":"module"}